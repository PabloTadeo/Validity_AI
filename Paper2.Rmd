---
title: "Paper2"
author: "Pablo Tadeo"
date: "2025-02-20"
output: html_document
---

# Table 1.

```{r}
# Instalar y cargar las librerías necesarias (si no están instaladas, descomentar la línea de instalación)
# install.packages("knitr")
library(knitr)

# Crear un data frame con las estrategias de búsqueda
data_busqueda <- data.frame(
  Base_de_datos = c("Web of Science", "Scopus", "EBSCO", "PubMed"),
  Estrategia_de_busqueda = c(
    'TS=(“vertical jump” OR “jump performance” OR “jump height”) AND TS=(“force platform” OR “force plate” OR “infrared sensor” OR “mobile application” OR “mobile app” OR “smartphone” OR “artificial intelligence” OR “machine learning” OR “computer vision” OR “deep learning”) AND TS=(“validity” OR “reliability” OR “accuracy” OR “effectiveness” OR “comparison” OR “technology evaluation”) AND PY=(2014-2024) AND LA=(“English” OR “Spanish”) AND OA=(“Open Access”) NOT TS=(“Rehabilitation” OR “Injury”)',
    'TITLE-ABS-KEY(“vertical jump” OR “jump performance” OR “jump height”) AND TITLE-ABS-KEY(“force platform” OR “force plate” OR “infrared sensor” OR “mobile application” OR “mobile app” OR “smartphone” OR “artificial intelligence” OR “machine learning” OR “computer vision” OR “deep learning”) AND TITLE-ABS-KEY(“validity” OR “reliability” OR “accuracy” OR “effectiveness” OR “comparison” OR “technology evaluation”) AND PUBYEAR > 2013 AND (LANGUAGE (english) OR LANGUAGE (spanish)) AND NOT TITLE-ABS-KEY(“rehabilitation” OR “injury”)',
    '(“vertical jump” OR “jump performance” OR “jump height”) AND (“force platform” OR “force plate”) AND (NOT (“rehabilitation” OR “injury”))',
    '(“Vertical Jump”[All Fields] OR “Jump Performance”[All Fields] OR “Jump Height”[All Fields]) AND (“Force Platform”[All Fields] OR “Force Plate”[All Fields] OR “Infrared Sensor”[All Fields] OR “Mobile Applications”[MeSH Terms] OR “Smartphone”[MeSH Terms] OR “Artificial Intelligence”[MeSH Terms] OR “Machine Learning”[MeSH Terms]) AND (“Validation Studies as Topic”[MeSH Terms] OR “Reproducibility of Results”[MeSH Terms] OR “validity”[All Fields] OR “reliability”[All Fields] OR “accuracy”[All Fields]) AND 2014/01/01:2024/12/31[Date - Publication] AND (“English”[Language] OR “Spanish”[Language])'
  )
)

# Crear la tabla con kable
tabla_busqueda <- kable(
  data_busqueda,
  caption = "Tabla 1. Resumen de las estrategias de búsqueda detallada de cada base de datos.",
  col.names = c("Base de datos", "Estrategia de búsqueda"),
  align = c("l", "l"), # Alinear a la izquierda ambas columnas
  format = "html" # Formato HTML para mejor visualización en RStudio
)

# Mostrar la tabla
tabla_busqueda
```

```{r}
# Cargar librerías necesarias
library(ggplot2)
library(dplyr)
library(knitr)
library(kableExtra)

# Crear el dataframe con las revistas y la cantidad de estudios publicados en cada una
journal_data <- data.frame(
  Journal = c("Journal of Strength and Conditioning Research", "PeerJ", "Sports", 
              "Sensors", "Journal of Sports Sciences", "Frontiers in Sports and Active Living",
              "International Journal of Sports Physical Therapy", "Biology of Sport", 
              "PloS One", "Physiological Measurement", "International Journal of Sports Medicine", 
              "Apunts Educación Física y Deportes", "Journal of Human Kinetics",
              "Frontiers in Bioengineering and Biotechnology", "Journal of Biomechanics",
              "European Journal of Sport Science", "Acta of Bioengineering and Biomechanics",
              "Procedia Engineering", "JMIR MHealth and UHealth", "International Journal of Kinesiology and Sports Science",
              "International Journal of Sports Physiology and Performance", "Physical Treatments: Specific Physical Therapy Journal",
              "Journal of Sports Science & Medicine", "BMC Sports Science, Medicine and Rehabilitation",
              "Journal of Strength and Conditioning Research", "Heliyon", "Mobile Information Systems"),
  Count = c(7, 3, 3, 3, 3, 2, 2, 2, 
            1, 1, 1, 1, 1, 1, 1, 1, 1, 
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
)

# Ordenar los datos por cantidad de estudios en orden descendente
journal_data <- journal_data %>% arrange(desc(Count))

# Generar la tabla con formato profesional
journal_table <- journal_data %>%
  kable("latex", booktabs = TRUE, caption = "Distribución de estudios por fuente (revista)") %>%
  kable_styling(latex_options = c("striped", "hold_position"))

# Mostrar la tabla
print(journal_table)

# Crear gráfico de barras
ggplot(journal_data, aes(x = reorder(Journal, Count), y = Count, fill = Count)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  theme_minimal() +
  labs(title = "Distribution of Studies by Journal",
       x = "Journal",
       y = "Number of Studies") +
  theme(axis.text.y = element_text(size = 10),
        axis.text.x = element_text(size = 10),
        plot.title = element_text(hjust = 0.5))
```

```{r}
# Cargar librerías necesarias
library(ggplot2)
library(dplyr)
library(knitr)
library(kableExtra)

# Crear el dataframe con las revistas y la cantidad de estudios publicados en cada una
journal_data <- data.frame(
  Journal = c("Journal of Strength and Conditioning Research", "PeerJ", "Sports", 
              "Sensors", "Journal of Sports Sciences", "Frontiers in Sports and Active Living",
              "International Journal of Sports Physical Therapy", "Biology of Sport", 
              "PloS One", "Physiological Measurement", "International Journal of Sports Medicine", 
              "Apunts Educación Física y Deportes", "Journal of Human Kinetics",
              "Frontiers in Bioengineering and Biotechnology", "Journal of Biomechanics",
              "European Journal of Sport Science", "Acta of Bioengineering and Biomechanics",
              "Procedia Engineering", "JMIR MHealth and UHealth", "International Journal of Kinesiology and Sports Science",
              "International Journal of Sports Physiology and Performance", "Physical Treatments: Specific Physical Therapy Journal",
              "Journal of Sports Science & Medicine", "BMC Sports Science, Medicine and Rehabilitation",
              "Journal of Strength and Conditioning Research", "Heliyon", "Mobile Information Systems"),
  Count = c(7, 3, 3, 3, 3, 2, 2, 2, 
            1, 1, 1, 1, 1, 1, 1, 1, 1, 
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
)

# Ordenar los datos por cantidad de estudios en orden descendente
journal_data <- journal_data %>% arrange(desc(Count))

# Generar la tabla con formato profesional
journal_table <- journal_data %>%
  kable("latex", booktabs = TRUE, caption = "Distribución de estudios por fuente (revista)") %>%
  kable_styling(latex_options = c("striped", "hold_position"))

# Mostrar la tabla
print(journal_table)

# Crear gráfico de barras
ggplot(journal_data, aes(x = reorder(Journal, Count), y = Count, fill = Count)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  theme_minimal() +
  labs(title = "Distribución de Estudios por Revista",
       x = "Revista",
       y = "Número de Estudios") +
  theme(axis.text.y = element_text(size = 10),
        axis.text.x = element_text(size = 10),
        plot.title = element_text(hjust = 0.5))
```

```{r}
# Instalar y cargar las librerías necesarias (si no están instaladas, descomentar la línea de instalación)
# install.packages("gt")
library(gt)

# Crear un data frame con las estrategias de búsqueda
data_busqueda <- data.frame(
  Base_de_datos = c("Web of Science", "Scopus", "EBSCO", "PubMed"),
  Estrategia_de_busqueda = c(
    'TS=(“vertical jump” OR “jump performance” OR “jump height”) AND TS=(“force platform” OR “force plate” OR “infrared sensor” OR “mobile application” OR “mobile app” OR “smartphone” OR “artificial intelligence” OR “machine learning” OR “computer vision” OR “deep learning”) AND TS=(“validity” OR “reliability” OR “accuracy” OR “effectiveness” OR “comparison” OR “technology evaluation”) AND PY=(2014-2024) AND LA=(“English” OR “Spanish”) AND OA=(“Open Access”) NOT TS=(“Rehabilitation” OR “Injury”)',
    'TITLE-ABS-KEY(“vertical jump” OR “jump performance” OR “jump height”) AND TITLE-ABS-KEY(“force platform” OR “force plate” OR “infrared sensor” OR “mobile application” OR “mobile app” OR “smartphone” OR “artificial intelligence” OR “machine learning” OR “computer vision” OR “deep learning”) AND TITLE-ABS-KEY(“validity” OR “reliability” OR “accuracy” OR “effectiveness” OR “comparison” OR “technology evaluation”) AND PUBYEAR > 2013 AND (LANGUAGE (english) OR LANGUAGE (spanish)) AND NOT TITLE-ABS-KEY(“rehabilitation” OR “injury”)',
    '(“vertical jump” OR “jump performance” OR “jump height”) AND (“force platform” OR “force plate”) AND (NOT (“rehabilitation” OR “injury”))',
    '(“Vertical Jump”[All Fields] OR “Jump Performance”[All Fields] OR “Jump Height”[All Fields]) AND (“Force Platform”[All Fields] OR “Force Plate”[All Fields] OR “Infrared Sensor”[All Fields] OR “Mobile Applications”[MeSH Terms] OR “Smartphone”[MeSH Terms] OR “Artificial Intelligence”[MeSH Terms] OR “Machine Learning”[MeSH Terms]) AND (“Validation Studies as Topic”[MeSH Terms] OR “Reproducibility of Results”[MeSH Terms] OR “validity”[All Fields] OR “reliability”[All Fields] OR “accuracy”[All Fields]) AND 2014/01/01:2024/12/31[Date - Publication] AND (“English”[Language] OR “Spanish”[Language])'
  )
)

# Crear la tabla con gt
tabla_busqueda_gt <- data_busqueda %>%
  gt() %>%
  tab_header(
    title = "Tabla 1. Resumen de las estrategias de búsqueda detallada de cada base de datos.",
    subtitle = "Estrategias utilizadas en las principales bases de datos."
  ) %>%
  cols_label(
    Base_de_datos = "Base de datos",
    Estrategia_de_busqueda = "Estrategia de búsqueda"
  ) %>%
  cols_align(
    align = "left",
    columns = everything()
  ) %>%
  tab_options(
    table.width = "100%", # Ancho de la tabla
    column_labels.font.weight = "bold", # Negrita en las etiquetas de las columnas
    table.font.size = "12px", # Tamaño de la fuente
    data_row.padding = "8px" # Espaciado entre filas
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels()
  ) %>%
  tab_style(
    style = cell_fill(color = "#f7f7f7"),
    locations = cells_body(rows = seq(1, nrow(data_busqueda), by = 2)) # Filas alternas con fondo gris claro
  )

# Mostrar la tabla
tabla_busqueda_gt
```

```{r}
# Cargar ggplot2 si no está cargado
library(ggplot2)

# Definir la ruta al escritorio
desktop_path <- "~/Desktop/Distribucion_Estudios_Revista.png"

# Configurar el dispositivo gráfico para guardar la imagen con dimensiones óptimas
png(filename = desktop_path, width = 2000, height = 1200, res = 300)

# Crear el gráfico con la distribución correcta y ajustes de diseño
ggplot(journal_data, aes(x = reorder(Journal, Count), y = Count, fill = Count)) +
  geom_bar(stat = "identity", show.legend = FALSE) +
  coord_flip() +  # Asegurar la orientación correcta
  scale_fill_gradient(low = "lightblue", high = "darkblue") +
  theme_minimal() +
  labs(title = "Distribución de Estudios por Revista",
       x = "Revista",
       y = "Número de Estudios") +
  theme(axis.text.y = element_text(size = 14, face = "bold"),
        axis.text.x = element_text(size = 12),
        plot.title = element_text(hjust = 0.5, size = 16, face = "bold"))

# Cerrar el dispositivo gráfico para guardar la imagen
dev.off()

# Mensaje de confirmación
print("Imagen guardada en el escritorio como 'Distribucion_Estudios_Revista.png'.")
```

```{r}
# Cargar librerías necesarias
library(gt)
library(gtsummary)
library(dplyr)

# Definir la ruta del archivo CSV en la carpeta Descargas (ajústala si es necesario)
file_path <- "~/Downloads/Tabla_Final_Grade.csv"

# Cargar los datos desde el archivo CSV
grade_data <- read.csv(file_path, stringsAsFactors = FALSE)

# Ver nombres exactos de las columnas en el archivo cargado
colnames(grade_data) 

# Renombrar columnas dinámicamente si es necesario (ajustar según los nombres reales)
colnames(grade_data) <- gsub("\\.+", " ", colnames(grade_data))  # Reemplaza puntos por espacios si hay errores de formato
colnames(grade_data) <- trimws(colnames(grade_data))  # Elimina espacios en blanco adicionales

# Verificar nombres corregidos
print(colnames(grade_data))

# Seleccionar columnas relevantes (ajustar según los nombres exactos del CSV)
grade_data <- grade_data %>%
  select(
    matches("Estudio"), 
    matches("Autores"), 
    matches("Resultado"), 
    matches("Factor"), 
    matches("Certeza")
  ) %>%
  rename(
    "Estudio" = matches("Estudio"),
    "Autores" = matches("Autores"),
    "Resultado Clave" = matches("Resultado"),
    "Factor de Evaluación" = matches("Factor"),
    "Nivel de Certeza" = matches("Certeza")
  )

# Crear la tabla GRADE profesional con gt()
grade_table <- grade_data %>%
  gt() %>%
  tab_header(
    title = md("**Resumen de la Evaluación de la Evidencia – Sistema GRADE**"),
    subtitle = md("Análisis de la calidad de los estudios incluidos en la revisión sistemática")
  ) %>%
  cols_label(
    Estudio = md("**Estudio**"),
    Autores = md("**Autores**"),
    `Resultado Clave` = md("**Resultado Clave**"),
    `Factor de Evaluación` = md("**Factor de Evaluación**"),
    `Nivel de Certeza` = md("**Nivel de Certeza**")
  ) %>%
  tab_style(
    style = list(
      cell_text(weight = "bold", align = "center")
    ),
    locations = cells_column_labels(everything())
  ) %>%
  data_color(
    columns = vars(`Nivel de Certeza`),
    colors = scales::col_factor(
      palette = c("red", "orange", "yellow", "green"),
      domain = c("Muy Baja", "Baja", "Moderada", "Alta")
    )
  ) %>%
  tab_options(
    table.font.size = px(14),
    heading.title.font.size = px(16),
    heading.subtitle.font.size = px(14),
    table.border.top.color = "black",
    table.border.bottom.color = "black"
  ) %>%
  cols_align(
    align = "center",
    columns = everything()
  )

# Guardar la tabla en un archivo de imagen (opcional, para reportes en PDF o Word)
gtsave(grade_table, filename = "~/Downloads/GRADE_Table.png")

# Mostrar la tabla en RStudio
grade_table
```

```{r}
# Cargar librerías necesarias
library(gt)
library(gtsummary)
library(dplyr)
library(stringr)  # Para manipulación de texto

# Definir la ruta del archivo CSV en la carpeta Descargas (ajústala si es necesario)
file_path <- "~/Downloads/Tabla_Final_Grade.csv"

# Cargar los datos desde el archivo CSV
grade_data <- read.csv(file_path, stringsAsFactors = FALSE)

# Ver nombres exactos de las columnas en el archivo cargado
colnames(grade_data) 

# Renombrar columnas dinámicamente si es necesario (ajustar según los nombres reales)
colnames(grade_data) <- gsub("\\.+", " ", colnames(grade_data))  # Reemplaza puntos por espacios si hay errores de formato
colnames(grade_data) <- trimws(colnames(grade_data))  # Elimina espacios en blanco adicionales

# Verificar nombres corregidos
print(colnames(grade_data))

# Seleccionar columnas relevantes (ajustar según los nombres exactos del CSV)
grade_data <- grade_data %>%
  select(
    matches("Estudio"), 
    matches("Autores"), 
    matches("Resultado"), 
    matches("Factor"), 
    matches("Certeza")
  ) %>%
  rename(
    "Estudio" = matches("Estudio"),
    "Autores" = matches("Autores"),
    "Resultado Clave" = matches("Resultado"),
    "Factor de Evaluación" = matches("Factor"),
    "Nivel de Certeza" = matches("Certeza")
  )

# Ajustar los títulos de los estudios para que cada palabra inicie con mayúscula
grade_data$Estudio <- str_to_title(grade_data$Estudio)

# Crear la tabla GRADE profesional con gt()
grade_table <- grade_data %>%
  gt() %>%
  tab_header(
    title = md("**Resumen de la Evaluación de la Evidencia – Sistema GRADE**"),
    subtitle = md("Análisis de la calidad de los estudios incluidos en la revisión sistemática")
  ) %>%
  cols_label(
    Estudio = md("**Estudio**"),
    Autores = md("**Autores**"),
    `Resultado Clave` = md("**Resultado Clave**"),
    `Factor de Evaluación` = md("**Factor de Evaluación**"),
    `Nivel de Certeza` = md("**Nivel de Certeza**")
  ) %>%
  tab_style(
    style = list(
      cell_text(weight = "bold", align = "center")
    ),
    locations = cells_column_labels(everything())
  ) %>%
  data_color(
    columns = vars(`Nivel de Certeza`),
    colors = scales::col_factor(
      palette = c("red", "orange", "yellow", "green"),
      domain = c("Muy Baja", "Baja", "Moderada", "Alta")
    )
  ) %>%
  tab_options(
    table.font.size = px(14),
    heading.title.font.size = px(16),
    heading.subtitle.font.size = px(14),
    table.border.top.color = "black",
    table.border.bottom.color = "black"
  ) %>%
  cols_align(
    align = "center",
    columns = everything()
  )

# Guardar la tabla en un archivo de imagen (opcional, para reportes en PDF o Word)
gtsave(grade_table, filename = "~/Downloads/GRADE_Table.png")

# Mostrar la tabla en RStudio
grade_table
```

```{r}
# Cargar librerías necesarias
library(gt)
library(dplyr)

# Seleccionar el archivo manualmente (aparecerá una ventana emergente para elegir el archivo)
file_path <- file.choose()

# Cargar los datos desde el archivo seleccionado
data_comparison <- read.csv(file_path, stringsAsFactors = FALSE)

# Mostrar las primeras filas para verificar que se cargó correctamente
head(data_comparison)
```

```{r}
# Mostrar los nombres de las columnas del archivo cargado
colnames(data_comparison)
```

```{r}
# Cargar librerías necesarias
library(gt)
library(dplyr)

# Verificar nombres de columnas
print(colnames(data_comparison))

# Eliminar columnas completamente vacías (sin nombre)
data_comparison <- data_comparison[, !is.na(colnames(data_comparison)) & colnames(data_comparison) != ""]

# Verificar nombres después de limpiar
print(colnames(data_comparison))

# Crear la tabla profesional con gt()
table_comparison <- data_comparison %>%
  gt() %>%
  tab_header(
    title = md("**Comparación de Tecnologías de Medición de Salto Vertical**"),
    subtitle = md("Evaluación de fiabilidad y validez de diferentes dispositivos")
  ) %>%
  cols_label(
    Tecnología = md("**Tecnología**"),
    Instrumento = md("**Instrumento/Dispositivo**"),
    ICC = md("**ICC**"),
    SEM = md("**SEM**"),
    Límites_Bland_Altman = md("**Límites de Bland-Altman**"),
    Observaciones = md("**Observaciones Clave**")
  ) %>%
  data_color(
    columns = vars(Tecnología),
    colors = scales::col_factor(
      palette = c("Plataformas de Fuerza" = "#FFDDC1",
                  "Sensores Infrarrojos" = "#C1E1FF",
                  "Aplicaciones Móviles" = "#C1FFC1",
                  "Captura sin Marcadores" = "#FFC1E1"),
      domain = unique(data_comparison$Tecnología)
    )
  ) %>%
  tab_style(
    style = list(
      cell_text(weight = "bold", align = "center")
    ),
    locations = cells_column_labels(everything())
  ) %>%
  cols_align(
    align = "center",
    columns = vars(ICC, SEM, Límites_Bland_Altman)
  ) %>%
  cols_align(
    align = "left",
    columns = vars(Observaciones)
  ) %>%
  tab_options(
    table.font.size = px(14),
    heading.title.font.size = px(18),
    heading.subtitle.font.size = px(14),
    column_labels.font.size = px(14),
    table.border.top.color = "black",
    table.border.bottom.color = "black"
  ) %>%
  opt_table_outline(style = "solid", color = "black", width = px(2))

# Guardar la tabla en un archivo de imagen (opcional, para reportes en PDF o Word)
gtsave(table_comparison, filename = "~/Downloads/Comparacion_Tecnologias.png")

# Mostrar la tabla en RStudio
table_comparison
```

```{r}
# Instalar las dependencias necesarias
install.packages("devtools")  # Si no lo tienes instalado
install.packages("scales")
install.packages("ggplot2")
install.packages("dplyr")

# Instalar `ggradar` desde GitHub (no está en CRAN)
devtools::install_github("ricardo-bion/ggradar")

# Cargar las librerías necesarias
library(ggradar)
library(ggplot2)
library(dplyr)
library(scales)
```

```{r}
# Instalar y cargar las librerías necesarias
install.packages("ggplot2")
install.packages("plotly")
install.packages("dplyr")
library(ggplot2)
library(plotly)
library(dplyr)

# Crear un data frame con los datos de Validity_ICC por dispositivo
data <- data.frame(
  Dispositivo = c(
    "Contact Mat", "My Jump 2 App", "Polar Vantage V2", "MyJump2", "VertVision App", 
    "My Jump App", "Kinovea Software", "My Jump 2 App", "BTG System", "Output Sport Device", 
    "SmartJump Contact Mat", "gFlight System", "Just Jump System", "Wheeler Jump Sensor", 
    "VJ Mat", "Optojump System", "IMU Device", "OpenPose-MA", "Kunwei Dual-Force Plate", 
    "Mixed-Methods RSI", "CMJ and IMTP Metrics", "Side Hop Test", "My Jump 2 App", 
    "My Jump 2 App", "K-Deltas Portable Force Platforms", "Linear Position Transducer", 
    "Squat Jump Thresholds", "Kinetic Asymmetries in Soccer Players", "Fitjump System", 
    "Squat Jump Movement Onset Thresholds", "Machine Learning Approach", "Polar V800", 
    "Force-Velocity Relationship", "MARG Sensor", "Common Vertical Jump Devices", 
    "Block Jump Height in Volleyball Players", "Optojump Next and BTS Smart-E", 
    "Portable Force Plates", "VJ Mat", "Wi-JumpLe System", "My Jump iPhone App", 
    "Wearable Inertial Sensor", "Inertial Units", "Optojump System", "Just Jump System", 
    "GymAware Linear Position Transducer", "My Jump App", "My Jump 2 App", 
    "Loaded Squat Jump", "My Jump App", "Markerless Motion Capture Smartphone App", 
    "AI-Driven My Jump 2 App"
  ),
  Validity_ICC = c(
    0.91, 0.95, 0.96, 0.955, 0.964, 0.948, 0.838, 0.843, 0.76, 0.825, 0.89, 0.83, 
    0.945, 0.997, 0.997, 0.989, 0.902, 0.86, 0.950, 0.685, 0.80, 0.994, 0.94, 
    0.999, 0.9459, 0.93, 0.67, 0.810, 0.93, 0.67, 0.999, 0.97, 0.68, 0.90, 0.99, 
    0.999, 0.98, 0.99, 0.997, 0.99, 0.997, 0.999, 0.93, 0.98, 0.96, 0.84, 0.95, 
    0.86, 0.67, 0.94, 0.969, 0.973
  )
)

# Ordenar los datos por Validity_ICC de mayor a menor
data <- data %>% arrange(desc(Validity_ICC))

# Crear un gráfico de barras con ggplot2
p <- ggplot(data, aes(x = reorder(Dispositivo, -Validity_ICC), y = Validity_ICC, fill = Validity_ICC)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = round(Validity_ICC, 3)), vjust = -0.5, size = 3.5, color = "black") +
  scale_fill_gradient(low = "#440154", high = "#fde725") +
  labs(
    title = "Validity_ICC por Dispositivo",
    x = "Dispositivo",
    y = "Validity ICC",
    fill = "Validity ICC"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold")
  )

# Convertir el gráfico de ggplot2 a interactivo con plotly
p_interactive <- ggplotly(p)

# Mostrar el gráfico interactivo
p_interactive
```

```{r}
# Instalar y cargar las librerías necesarias
install.packages("ggplot2")
install.packages("plotly")
install.packages("dplyr")
library(ggplot2)
library(plotly)
library(dplyr)

# Crear un data frame con los datos de Validity_ICC por dispositivo
data <- data.frame(
  Dispositivo = c(
    "Contact Mat", "My Jump 2 App", "Polar Vantage V2", "MyJump2", "VertVision App", 
    "My Jump App", "Kinovea Software", "My Jump 2 App", "BTG System", "Output Sport Device", 
    "SmartJump Contact Mat", "gFlight System", "Just Jump System", "Wheeler Jump Sensor", 
    "VJ Mat", "Optojump System", "IMU Device", "OpenPose-MA", "Kunwei Dual-Force Plate", 
    "Mixed-Methods RSI", "CMJ and IMTP Metrics", "Side Hop Test", "My Jump 2 App", 
    "My Jump 2 App", "K-Deltas Portable Force Platforms", "Linear Position Transducer", 
    "Squat Jump Thresholds", "Kinetic Asymmetries in Soccer Players", "Fitjump System", 
    "Squat Jump Movement Onset Thresholds", "Machine Learning Approach", "Polar V800", 
    "Force-Velocity Relationship", "MARG Sensor", "Common Vertical Jump Devices", 
    "Block Jump Height in Volleyball Players", "Optojump Next and BTS Smart-E", 
    "Portable Force Plates", "VJ Mat", "Wi-JumpLe System", "My Jump iPhone App", 
    "Wearable Inertial Sensor", "Inertial Units", "Optojump System", "Just Jump System", 
    "GymAware Linear Position Transducer", "My Jump App", "My Jump 2 App", 
    "Loaded Squat Jump", "My Jump App", "Markerless Motion Capture Smartphone App", 
    "AI-Driven My Jump 2 App"
  ),
  Validity_ICC = c(
    0.91, 0.95, 0.96, 0.955, 0.964, 0.948, 0.838, 0.843, 0.76, 0.825, 0.89, 0.83, 
    0.945, 0.997, 0.997, 0.989, 0.902, 0.86, 0.950, 0.685, 0.80, 0.994, 0.94, 
    0.999, 0.9459, 0.93, 0.67, 0.810, 0.93, 0.67, 0.999, 0.97, 0.68, 0.90, 0.99, 
    0.999, 0.98, 0.99, 0.997, 0.99, 0.997, 0.999, 0.93, 0.98, 0.96, 0.84, 0.95, 
    0.86, 0.67, 0.94, 0.969, 0.973
  )
)

# Eliminar duplicados y mantener el valor más alto de Validity_ICC para cada dispositivo
data <- data %>%
  group_by(Dispositivo) %>%
  summarise(Validity_ICC = max(Validity_ICC)) %>%
  arrange(desc(Validity_ICC))

# Crear un gráfico de barras horizontales con ggplot2
p <- ggplot(data, aes(x = Validity_ICC, y = reorder(Dispositivo, Validity_ICC), fill = Validity_ICC)) +
  geom_bar(stat = "identity", fill = "#1f77b4") +
  geom_text(aes(label = round(Validity_ICC, 3)), hjust = -0.1, size = 3.5, color = "black") +
  labs(
    title = "Validity_ICC por Dispositivo",
    x = "Validity ICC",
    y = "Dispositivo"
  ) +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 10),
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    panel.grid.major.y = element_blank()
  ) +
  scale_x_continuous(expand = expansion(mult = c(0, 0.1))) # Ajustar el espacio en el eje X

# Convertir el gráfico de ggplot2 a interactivo con plotly
p_interactive <- ggplotly(p)

# Mostrar el gráfico interactivo
p_interactive
```

```{r}
# Cargar librerías necesarias
library(ggplot2)
library(dplyr)

# Crear los datos de Validity_ICC por dispositivo
data <- data.frame(
  Dispositivo = c(
    "Contact Mat", "My Jump 2 App", "Polar Vantage V2", "MyJump2", "VertVision App", 
    "My Jump App", "Kinovea Software", "My Jump 2 App", "BTG System", "Output Sport Device", 
    "SmartJump Contact Mat", "gFlight System", "Just Jump System", "Wheeler Jump Sensor", 
    "VJ Mat", "Optojump System", "IMU Device", "OpenPose-MA", "Kunwei Dual-Force Plate", 
    "Mixed-Methods RSI", "CMJ and IMTP Metrics", "Side Hop Test", "My Jump 2 App", 
    "My Jump 2 App", "K-Deltas Portable Force Platforms", "Linear Position Transducer", 
    "Squat Jump Thresholds", "Kinetic Asymmetries in Soccer Players", "Fitjump System", 
    "Squat Jump Movement Onset Thresholds", "Machine Learning Approach", "Polar V800", 
    "Force-Velocity Relationship", "MARG Sensor", "Common Vertical Jump Devices", 
    "Block Jump Height in Volleyball Players", "Optojump Next and BTS Smart-E", 
    "Portable Force Plates", "VJ Mat", "Wi-JumpLe System", "My Jump iPhone App", 
    "Wearable Inertial Sensor", "Inertial Units", "Optojump System", "Just Jump System", 
    "GymAware Linear Position Transducer", "My Jump App", "My Jump 2 App", 
    "Loaded Squat Jump", "My Jump App", "Markerless Motion Capture Smartphone App", 
    "AI-Driven My Jump 2 App"
  ),
  Validity_ICC = c(
    0.91, 0.95, 0.96, 0.955, 0.964, 0.948, 0.838, 0.843, 0.76, 0.825, 0.89, 0.83, 
    0.945, 0.997, 0.997, 0.989, 0.902, 0.86, 0.950, 0.685, 0.80, 0.994, 0.94, 
    0.999, 0.9459, 0.93, 0.67, 0.810, 0.93, 0.67, 0.999, 0.97, 0.68, 0.90, 0.99, 
    0.999, 0.98, 0.99, 0.997, 0.99, 0.997, 0.999, 0.93, 0.98, 0.96, 0.84, 0.95, 
    0.86, 0.67, 0.94, 0.969, 0.973
  )
)

# Ordenar los datos por ICC de mayor a menor
data <- data %>% arrange(desc(Validity_ICC))

# Crear el gráfico de barras con ggplot2 y mejoras en visualización
ggplot(data, aes(x = reorder(Dispositivo, Validity_ICC), y = Validity_ICC, fill = Validity_ICC)) +
  geom_bar(stat = "identity", show.legend = FALSE) +
  geom_text(aes(label = round(Validity_ICC, 3)), 
            hjust = -0.1, size = 4, color = "black", fontface = "bold") +  # Ajuste del texto
  scale_fill_gradient(low = "yellow", high = "darkgreen") +
  labs(
    title = "ICC de Validez por Dispositivo",
    x = "Dispositivo",
    y = "ICC de Validez"
  ) +
  coord_flip() +  # Para girar el gráfico y mejorar la legibilidad
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
    axis.text.y = element_text(size = 10, face = "bold"),  # Aumenta la legibilidad de los dispositivos
    axis.text.x = element_text(size = 12),
    plot.margin = margin(10, 10, 10, 10)  # Ajusta los márgenes para evitar cortes
  )
```

```{r}
# Instalar y cargar las librerías necesarias (si no están instaladas, descomentar la línea de instalación)
# install.packages("ggplot2")
# install.packages("plotly")
# install.packages("dplyr")

library(ggplot2)
library(plotly)
library(dplyr)

# Crear un data frame con los datos de Validity_ICC por dispositivo
data <- data.frame(
  Dispositivo = c(
    "Contact Mat", "My Jump 2 App", "Polar Vantage V2", "MyJump2", "VertVision App", 
    "My Jump App", "Kinovea Software", "My Jump 2 App", "BTG System", "Output Sport Device", 
    "SmartJump Contact Mat", "gFlight System", "Just Jump System", "Wheeler Jump Sensor", 
    "VJ Mat", "Optojump System", "IMU Device", "OpenPose-MA", "Kunwei Dual-Force Plate", 
    "Mixed-Methods RSI", "CMJ and IMTP Metrics", "Side Hop Test", "My Jump 2 App", 
    "My Jump 2 App", "K-Deltas Portable Force Platforms", "Linear Position Transducer", 
    "Squat Jump Thresholds", "Kinetic Asymmetries in Soccer Players", "Fitjump System", 
    "Squat Jump Movement Onset Thresholds", "Machine Learning Approach", "Polar V800", 
    "Force-Velocity Relationship", "MARG Sensor", "Common Vertical Jump Devices", 
    "Block Jump Height in Volleyball Players", "Optojump Next and BTS Smart-E", 
    "Portable Force Plates", "VJ Mat", "Wi-JumpLe System", "My Jump iPhone App", 
    "Wearable Inertial Sensor", "Inertial Units", "Optojump System", "Just Jump System", 
    "GymAware Linear Position Transducer", "My Jump App", "My Jump 2 App", 
    "Loaded Squat Jump", "My Jump App", "Markerless Motion Capture Smartphone App", 
    "AI-Driven My Jump 2 App"
  ),
  Validity_ICC = c(
    0.91, 0.95, 0.96, 0.955, 0.964, 0.948, 0.838, 0.843, 0.76, 0.825, 0.89, 0.83, 
    0.945, 0.997, 0.997, 0.989, 0.902, 0.86, 0.950, 0.685, 0.80, 0.994, 0.94, 
    0.999, 0.9459, 0.93, 0.67, 0.810, 0.93, 0.67, 0.999, 0.97, 0.68, 0.90, 0.99, 
    0.999, 0.98, 0.99, 0.997, 0.99, 0.997, 0.999, 0.93, 0.98, 0.96, 0.84, 0.95, 
    0.86, 0.67, 0.94, 0.969, 0.973
  )
)

# Eliminar duplicados y mantener el valor más alto de Validity_ICC para cada dispositivo
data <- data %>%
  group_by(Dispositivo) %>%
  summarise(Validity_ICC = max(Validity_ICC)) %>%
  arrange(desc(Validity_ICC))

# Crear un gráfico de barras horizontales con ggplot2 y escala de colores
p <- ggplot(data, aes(x = Validity_ICC, y = reorder(Dispositivo, Validity_ICC), fill = Validity_ICC)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = round(Validity_ICC, 3)), hjust = -0.1, size = 3.5, color = "black") +
  scale_fill_gradient(low = "red", high = "darkgreen", name = "ICC de Validez") + # Escala de colores
  labs(
    title = "ICC de Validez por Dispositivo",
    x = "ICC de Validez",
    y = "Dispositivo"
  ) +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 10, face = "bold"), # Ajuste de tamaño para evitar solapamientos
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    panel.grid.major.y = element_blank()
  ) +
  scale_x_continuous(expand = expansion(mult = c(0, 0.1))) # Ajustar el espacio en el eje X

# Convertir el gráfico de ggplot2 a interactivo con plotly
p_interactive <- ggplotly(p)

# Mostrar el gráfico interactivo con la escala de colores corregida
p_interactive
```

```{r}
library(ggplot2)
library(plotly)
library(dplyr)

# Crear un data frame con los datos de Validity_ICC por dispositivo
data <- data.frame(
  Device = c(
    "Contact Mat", "My Jump 2 App", "Polar Vantage V2", "MyJump2", "VertVision App", 
    "My Jump App", "Kinovea Software", "My Jump 2 App", "BTG System", "Output Sport Device", 
    "SmartJump Contact Mat", "gFlight System", "Just Jump System", "Wheeler Jump Sensor", 
    "VJ Mat", "Optojump System", "IMU Device", "OpenPose-MA", "Kunwei Dual-Force Plate", 
    "Mixed-Methods RSI", "CMJ and IMTP Metrics", "Side Hop Test", "My Jump 2 App", 
    "My Jump 2 App", "K-Deltas Portable Force Platforms", "Linear Position Transducer", 
    "Squat Jump Thresholds", "Kinetic Asymmetries in Soccer Players", "Fitjump System", 
    "Squat Jump Movement Onset Thresholds", "Machine Learning Approach", "Polar V800", 
    "Force-Velocity Relationship", "MARG Sensor", "Common Vertical Jump Devices", 
    "Block Jump Height in Volleyball Players", "Optojump Next and BTS Smart-E", 
    "Portable Force Plates", "VJ Mat", "Wi-JumpLe System", "My Jump iPhone App", 
    "Wearable Inertial Sensor", "Inertial Units", "Optojump System", "Just Jump System", 
    "GymAware Linear Position Transducer", "My Jump App", "My Jump 2 App", 
    "Loaded Squat Jump", "My Jump App", "Markerless Motion Capture Smartphone App", 
    "AI-Driven My Jump 2 App"
  ),
  Validity_ICC = c(
    0.91, 0.95, 0.96, 0.955, 0.964, 0.948, 0.838, 0.843, 0.76, 0.825, 0.89, 0.83, 
    0.945, 0.997, 0.997, 0.989, 0.902, 0.86, 0.950, 0.685, 0.80, 0.994, 0.94, 
    0.999, 0.9459, 0.93, 0.67, 0.810, 0.93, 0.67, 0.999, 0.97, 0.68, 0.90, 0.99, 
    0.999, 0.98, 0.99, 0.997, 0.99, 0.997, 0.999, 0.93, 0.98, 0.96, 0.84, 0.95, 
    0.86, 0.67, 0.94, 0.969, 0.973
  )
)

# Eliminar duplicados y mantener el valor más alto de Validity_ICC para cada dispositivo
data <- data %>%
  group_by(Device) %>%
  summarise(Validity_ICC = max(Validity_ICC)) %>%
  arrange(desc(Validity_ICC))

# Crear un gráfico de barras horizontales con ggplot2 y escala de colores
p <- ggplot(data, aes(x = Validity_ICC, y = reorder(Device, Validity_ICC), fill = Validity_ICC)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = round(Validity_ICC, 3)), hjust = -0.1, size = 3.5, color = "black") +
  scale_fill_gradient(low = "red", high = "darkgreen", name = "Validity ICC") + # Escala de colores
  labs(
    title = "Validity ICC by Device",
    x = "Validity ICC",
    y = "Device"
  ) +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 10, face = "bold", margin = margin(r = 10)), # Ajuste de espacio en el eje Y
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    panel.grid.major.y = element_blank()
  ) +
  scale_x_continuous(expand = expansion(mult = c(0, 0.1))) # Ajustar el espacio en el eje X

# Convertir el gráfico de ggplot2 a interactivo con plotly
p_interactive <- ggplotly(p)

# Mostrar el gráfico interactivo con la escala de colores corregida
p_interactive

```

```{r}
# Instalar y cargar las librerías necesarias (si no están instaladas, descomentar la línea de instalación)
# install.packages("ggplot2")
# install.packages("plotly")
# install.packages("dplyr")

library(ggplot2)
library(plotly)
library(dplyr)

# Crear un data frame con los datos de Reliability_ICC por dispositivo
data_reliability <- data.frame(
  Dispositivo = c(
    "Contact Mat", "My Jump 2 App", "Polar Vantage V2", "MyJump2", "VertVision App", 
    "My Jump App", "Kinovea Software", "My Jump 2 App", "BTG System", "Output Sport Device", 
    "SmartJump Contact Mat", "gFlight System", "Just Jump System", "Wheeler Jump Sensor", 
    "VJ Mat", "Optojump System", "IMU Device", "OpenPose-MA", "Kunwei Dual-Force Plate", 
    "Mixed-Methods RSI", "CMJ and IMTP Metrics", "Side Hop Test", "My Jump 2 App", 
    "My Jump 2 App", "K-Deltas Portable Force Platforms", "Linear Position Transducer", 
    "Squat Jump Thresholds", "Kinetic Asymmetries in Soccer Players", "Fitjump System", 
    "Squat Jump Movement Onset Thresholds", "Machine Learning Approach", "Polar V800", 
    "Force-Velocity Relationship", "MARG Sensor", "Common Vertical Jump Devices", 
    "Block Jump Height in Volleyball Players", "Optojump Next and BTS Smart-E", 
    "Portable Force Plates", "VJ Mat", "Wi-JumpLe System", "My Jump iPhone App", 
    "Wearable Inertial Sensor", "Inertial Units", "Optojump System", "Just Jump System", 
    "GymAware Linear Position Transducer", "My Jump App", "My Jump 2 App", 
    "Loaded Squat Jump", "My Jump App", "Markerless Motion Capture Smartphone App", 
    "AI-Driven My Jump 2 App"
  ),
  Reliability_ICC = c(
    0.87, 0.95, 0.96, 0.975, 0.99, 0.948, 0.903, 0.843, 0.8, 0.825, 0.89, 0.83, 
    0.945, 0.997, 0.997, 0.989, 0.902, 0.86, 0.950, 0.685, 0.80, 0.994, 0.94, 
    0.999, 0.9459, 0.93, 0.67, 0.810, 0.93, 0.67, 0.999, 0.97, 0.68, 0.90, 0.99, 
    0.999, 0.98, 0.99, 0.997, 0.99, 0.997, 0.999, 0.93, 0.98, 0.96, 0.84, 0.95, 
    0.86, 0.67, 0.94, 0.969, 0.973
  )
)

# Eliminar duplicados y mantener el valor más alto de Reliability_ICC para cada dispositivo
data_reliability <- data_reliability %>%
  group_by(Dispositivo) %>%
  summarise(Reliability_ICC = max(Reliability_ICC)) %>%
  arrange(desc(Reliability_ICC))

# Crear un gráfico de barras horizontales con ggplot2 y nueva escala de colores
p_reliability <- ggplot(data_reliability, aes(x = Reliability_ICC, y = reorder(Dispositivo, Reliability_ICC), fill = Reliability_ICC)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = round(Reliability_ICC, 3)), hjust = -0.1, size = 3.5, color = "black") +
  scale_fill_gradientn(
    colours = c("darkred", "orange", "yellow", "green", "darkgreen"), # Nueva escala de colores
    values = c(0, 0.6, 0.8, 0.9, 1),  # Ajuste de valores en la escala
    name = "ICC de Fiabilidad"
  ) +
  labs(
    title = "ICC de Fiabilidad por Dispositivo",
    x = "ICC de Fiabilidad",
    y = "Dispositivo"
  ) +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 10, face = "bold"), # Ajuste de tamaño para evitar solapamientos
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    panel.grid.major.y = element_blank()
  ) +
  scale_x_continuous(expand = expansion(mult = c(0, 0.1))) # Ajustar el espacio en el eje X

# Convertir el gráfico de ggplot2 a interactivo con plotly
p_reliability_interactive <- ggplotly(p_reliability)

# Mostrar el gráfico interactivo con la escala de colores corregida
p_reliability_interactive
```

```{r}
library(ggplot2)

# Datos basados en la imagen original
factors <- c(
  "Risk of Bias", "Inconsistency", "Imprecision", "Study Limitations", "Consistency", 
  "Precision", "Systematic Bias", "Applicability", "Consistency and Concurrent Validity", 
  "Applicability and Generalization", "Validity", "Magnitude", "Reliability", 
  "Indirectness", "Publication Bias"
)

# Ajustar el orden de los niveles de certeza
certainty_levels <- c("High", "Moderate", "Low", "Very Low")

# Datos de la cantidad de estudios por nivel de certeza y factor de evaluación
data <- data.frame(
  Factor = rep(factors, each = 4),
  Certainty = factor(rep(certainty_levels, times = length(factors)), levels = certainty_levels),
  Count = c(
    5, 15, 25, 10,  # Risk of Bias
    2, 8, 20, 12,  # Inconsistency
    1, 4, 6, 2,  # Imprecision
    3, 10, 8, 20,  # Study Limitations
    0, 2, 5, 55,  # Consistency
    0, 0, 2, 10,  # Precision
    1, 3, 3, 7,  # Systematic Bias
    0, 2, 5, 10,  # Applicability
    0, 4, 6, 5,  # Consistency and Concurrent Validity
    0, 3, 5, 5,  # Applicability and Generalization
    0, 2, 3, 5,  # Validity
    0, 1, 2, 4,  # Magnitude
    0, 1, 2, 5,  # Reliability
    1, 2, 3, 2,  # Indirectness
    1, 3, 4, 2   # Publication Bias
  )
)

# Crear gráfico con ggplot2
ggplot(data, aes(x = Factor, y = Count, fill = Certainty)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_manual(values = c("High" = "green", "Moderate" = "yellow", "Low" = "orange", "Very Low" = "red")) +
  labs(
    title = "GRADE Analysis: Distribution of Certainty Levels by Evaluation Factor",
    x = "Evaluation Factor",
    y = "Number of Studies",
    fill = "Certainty Level"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "top"
  )
```

```{r}
library(ggplot2)
library(plotly)
library(dplyr)

# Crear un data frame con los datos de Reliability_ICC por dispositivo
data_reliability <- data.frame(
  Device = c(
    "Contact Mat", "My Jump 2 App", "Polar Vantage V2", "MyJump2", "VertVision App", 
    "My Jump App", "Kinovea Software", "My Jump 2 App", "BTG System", "Output Sport Device", 
    "SmartJump Contact Mat", "gFlight System", "Just Jump System", "Wheeler Jump Sensor", 
    "VJ Mat", "Optojump System", "IMU Device", "OpenPose-MA", "Kunwei Dual-Force Plate", 
    "Mixed-Methods RSI", "CMJ and IMTP Metrics", "Side Hop Test", "My Jump 2 App", 
    "My Jump 2 App", "K-Deltas Portable Force Platforms", "Linear Position Transducer", 
    "Squat Jump Thresholds", "Kinetic Asymmetries in Soccer Players", "Fitjump System", 
    "Squat Jump Movement Onset Thresholds", "Machine Learning Approach", "Polar V800", 
    "Force-Velocity Relationship", "MARG Sensor", "Common Vertical Jump Devices", 
    "Block Jump Height in Volleyball Players", "Optojump Next and BTS Smart-E", 
    "Portable Force Plates", "VJ Mat", "Wi-JumpLe System", "My Jump iPhone App", 
    "Wearable Inertial Sensor", "Inertial Units", "Optojump System", "Just Jump System", 
    "GymAware Linear Position Transducer", "My Jump App", "My Jump 2 App", 
    "Loaded Squat Jump", "My Jump App", "Markerless Motion Capture Smartphone App", 
    "AI-Driven My Jump 2 App"
  ),
  Reliability_ICC = c(
    0.87, 0.95, 0.96, 0.975, 0.99, 0.948, 0.903, 0.843, 0.8, 0.825, 0.89, 0.83, 
    0.945, 0.997, 0.997, 0.989, 0.902, 0.86, 0.950, 0.685, 0.80, 0.994, 0.94, 
    0.999, 0.9459, 0.93, 0.67, 0.810, 0.93, 0.67, 0.999, 0.97, 0.68, 0.90, 0.99, 
    0.999, 0.98, 0.99, 0.997, 0.99, 0.997, 0.999, 0.93, 0.98, 0.96, 0.84, 0.95, 
    0.86, 0.67, 0.94, 0.969, 0.973
  )
)

# Eliminar duplicados y mantener el valor más alto de Reliability_ICC para cada dispositivo
data_reliability <- data_reliability %>%
  group_by(Device) %>%
  summarise(Reliability_ICC = max(Reliability_ICC)) %>%
  arrange(desc(Reliability_ICC))

# Crear un gráfico de barras horizontales con ggplot2 y nueva escala de colores
p_reliability <- ggplot(data_reliability, aes(x = Reliability_ICC, y = reorder(Device, Reliability_ICC), fill = Reliability_ICC)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = round(Reliability_ICC, 3)), hjust = -0.1, size = 3.5, color = "black") +
  scale_fill_gradientn(
    colours = c("darkred", "orange", "yellow", "green", "darkgreen"), # Nueva escala de colores
    values = c(0, 0.6, 0.8, 0.9, 1),  # Ajuste de valores en la escala
    name = "Reliability ICC"
  ) +
  labs(
    title = "Reliability ICC by Device",
    x = "Reliability ICC",
    y = "Device"
  ) +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 10, face = "bold"), # Ajuste de tamaño para evitar solapamientos
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    panel.grid.major.y = element_blank()
  ) +
  scale_x_continuous(expand = expansion(mult = c(0, 0.1))) # Ajustar el espacio en el eje X

# Convertir el gráfico de ggplot2 a interactivo con plotly
p_reliability_interactive <- ggplotly(p_reliability)

# Mostrar el gráfico interactivo con la escala de colores corregida
p_reliability_interactive

```

```{r}
# Seleccionar el archivo manualmente (aparecerá una ventana emergente para elegir el archivo)
file_path <- file.choose()

# Cargar los datos desde el archivo seleccionado
data_comparison <- read.csv(file_path, stringsAsFactors = FALSE)

# Mostrar las primeras filas para verificar que se cargó correctamente
head(data_comparison)
```

```{r}
library(ggplot2)
library(dplyr)
library(readr)

# Cargar el archivo CSV
df <- read_csv("GRADE_Systematic_Reviewer-Oficial.csv")

# Asegurar que los niveles de certeza estén en el orden correcto
df$Certainly_Level <- factor(df$Certainly_Level, 
                             levels = c("High", "Moderate", "Low", "Very Low"), 
                             ordered = TRUE)

# Crear gráfico con ggplot2
ggplot(df, aes(x = Factor, fill = Certainly_Level)) +
  geom_bar(position = "stack") +
  scale_fill_manual(values = c("green", "yellow", "orange", "red")) +
  labs(
    title = "GRADE Analysis: Distribution of Certainty Levels by Evaluation Factor",
    x = "Evaluation Factor",
    y = "Number of Studies",
    fill = "Certainty Level"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "top"
  )

```
